

WITH monthly_sales AS (
    SELECT 
        customer_id,
        product_category,
        order_date,
        total_amount,
        ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY order_date DESC) as recent_order_rank,
        SUM(total_amount) OVER (PARTITION BY customer_id) as customer_lifetime_value,
        LAG(total_amount, 1) OVER (PARTITION BY customer_id ORDER BY order_date) as previous_order_amount,
        DENSE_RANK() OVER (ORDER BY total_amount DESC) as amount_rank
    FROM sales_database.ecommerce_schema.customer_orders co
    LEFT JOIN sales_database.ecommerce_schema.product_catalog pc ON co.product_id = pc.product_id
    WHERE order_date >= DATEADD(MONTH, -12, GETDATE())
        AND order_status IN ('completed', 'shipped', 'delivered')
        AND customer_email LIKE '%@gmail.com'
),
customer_segments AS (
    SELECT 
        customer_id,
        CASE 
            WHEN customer_lifetime_value > 10000 THEN 'VIP'
            WHEN customer_lifetime_value > 5000 THEN 'Premium'
            WHEN customer_lifetime_value > 1000 THEN 'Standard'
            ELSE 'Basic'
        END as customer_segment,
        COUNT(*) as total_orders,
        AVG(total_amount) as avg_order_value
    FROM monthly_sales
    WHERE recent_order_rank <= 5
    GROUP BY customer_id, customer_lifetime_value
    HAVING COUNT(*) >= 2
)
SELECT 
    cs.customer_segment,
    COUNT(DISTINCT cs.customer_id) as segment_customer_count,
    ROUND(AVG(cs.avg_order_value), 2) as segment_avg_order_value,
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY cs.total_orders) as median_orders_per_customer,
    STRING_AGG(DISTINCT ms.product_category, ', ') as popular_categories
FROM customer_segments cs
JOIN monthly_sales ms ON cs.customer_id = ms.customer_id
JOIN sales_database.ecommerce_schema.customer_profiles cp ON cs.customer_id = cp.customer_id
WHERE cp.registration_date <= DATEADD(YEAR, -1, CURRENT_DATE)
    AND cp.customer_status = 'active'
    AND cp.preferred_language IN ('English', 'Spanish', 'French')
GROUP BY cs.customer_segment
ORDER BY segment_avg_order_value DESC;
```

## Test Query 2: Financial Data with Recursive CTE and Advanced Functions

```sql
WITH RECURSIVE employee_hierarchy AS (
    -- Base case: Top-level managers
    SELECT 
        employee_id,
        employee_name,
        manager_id,
        department_name,
        salary,
        bonus_percentage,
        1 as hierarchy_level,
        CAST(employee_name AS VARCHAR(1000)) as hierarchy_path
    FROM hr_system.company_db.employees e
    JOIN hr_system.company_db.departments d ON e.department_id = d.department_id
    WHERE manager_id IS NULL
    
    UNION ALL
    
    -- Recursive case: Subordinates
    SELECT 
        e.employee_id,
        e.employee_name,
        e.manager_id,
        d.department_name,
        e.salary,
        e.bonus_percentage,
        eh.hierarchy_level + 1,
        CONCAT(eh.hierarchy_path, ' -> ', e.employee_name)
    FROM hr_system.company_db.employees e
    JOIN hr_system.company_db.departments d ON e.department_id = d.department_id
    JOIN employee_hierarchy eh ON e.manager_id = eh.employee_id
    WHERE eh.hierarchy_level < 10  -- Prevent infinite recursion
),
salary_analytics AS (
    SELECT 
        department_name,
        hierarchy_level,
        employee_name,
        salary,
        bonus_percentage,
        salary * (1 + bonus_percentage/100) as total_compensation,
        NTILE(4) OVER (PARTITION BY department_name ORDER BY salary) as salary_quartile,
        PERCENT_RANK() OVER (ORDER BY salary) as salary_percentile,
        FIRST_VALUE(employee_name) OVER (
            PARTITION BY department_name 
            ORDER BY salary DESC 
            ROWS UNBOUNDED PRECEDING
        ) as highest_paid_in_dept
    FROM employee_hierarchy
    WHERE salary IS NOT NULL
)
SELECT 
    sa.department_name,
    sa.hierarchy_level,
    COUNT(*) as employee_count,
    ROUND(AVG(sa.total_compensation), 2) as avg_total_comp,
    ROUND(STDDEV(sa.salary), 2) as salary_std_deviation,
    MIN(sa.salary) as min_salary,
    MAX(sa.salary) as max_salary,
    ROUND(
        (MAX(sa.salary) - MIN(sa.salary))::DECIMAL / NULLIF(MIN(sa.salary), 0) * 100, 
        2
    ) as salary_range_percentage,
    STRING_AGG(
        DISTINCT CASE WHEN sa.salary_quartile = 4 THEN sa.employee_name END, 
        '; ' ORDER BY sa.employee_name
    ) as top_quartile_employees
FROM salary_analytics sa
LEFT JOIN hr_system.company_db.performance_reviews pr 
    ON sa.employee_name = pr.employee_name 
    AND pr.review_year = EXTRACT(YEAR FROM CURRENT_DATE) - 1
WHERE sa.total_compensation > (
    SELECT AVG(total_compensation) * 0.8 
    FROM salary_analytics sa2 
    WHERE sa2.department_name = sa.department_name
)
GROUP BY sa.department_name, sa.hierarchy_level
HAVING COUNT(*) >= 3
ORDER BY sa.department_name, sa.hierarchy_level;
```

## Test Query 3: Data Warehouse Query with PIVOT, Multiple JOINs, and Stored Procedures

```sql
DECLARE @start_date DATE = '2023-01-01';
DECLARE @end_date DATE = '2023-12-31';
DECLARE @min_transaction_amount DECIMAL(10,2) = 100.00;

WITH transaction_base AS (
    SELECT 
        t.transaction_id,
        t.customer_id,
        t.merchant_id,
        t.transaction_date,
        t.transaction_amount,
        t.transaction_type,
        t.currency_code,
        c.customer_name,
        c.customer_email,
        c.customer_phone,
        m.merchant_name,
        m.merchant_category,
        m.merchant_country,
        cc.exchange_rate,
        t.transaction_amount * cc.exchange_rate as amount_usd,
        CASE 
            WHEN t.transaction_date BETWEEN '2023-11-24' AND '2023-11-26' THEN 'Black Friday'
            WHEN t.transaction_date BETWEEN '2023-12-24' AND '2023-12-26' THEN 'Christmas'
            WHEN DATEPART(DAYOFWEEK, t.transaction_date) IN (1, 7) THEN 'Weekend'
            ELSE 'Regular'
        END as transaction_period
    FROM financial_db.payments_schema.transactions t
    INNER JOIN financial_db.payments_schema.customers c ON t.customer_id = c.customer_id
    INNER JOIN financial_db.payments_schema.merchants m ON t.merchant_id = m.merchant_id
    LEFT JOIN financial_db.reference_data.currency_conversion cc 
        ON t.currency_code = cc.from_currency 
        AND cc.to_currency = 'USD'
        AND cc.conversion_date = CAST(t.transaction_date AS DATE)
    WHERE t.transaction_date BETWEEN @start_date AND @end_date
        AND t.transaction_amount >= @min_transaction_amount
        AND t.transaction_status IN ('approved', 'completed')
        AND c.customer_status = 'active'
        AND m.merchant_status <> 'suspended'
),
monthly_pivot_data AS (
    SELECT 
        merchant_category,
        customer_id,
        [1] as Jan_Amount, [2] as Feb_Amount, [3] as Mar_Amount,
        [4] as Apr_Amount, [5] as May_Amount, [6] as Jun_Amount,
        [7] as Jul_Amount, [8] as Aug_Amount, [9] as Sep_Amount,
        [10] as Oct_Amount, [11] as Nov_Amount, [12] as Dec_Amount
    FROM (
        SELECT 
            merchant_category,
            customer_id,
            MONTH(transaction_date) as transaction_month,
            SUM(amount_usd) as monthly_total
        FROM transaction_base
        GROUP BY merchant_category, customer_id, MONTH(transaction_date)
    ) as source_table
    PIVOT (
        SUM(monthly_total)
        FOR transaction_month IN ([1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12])
    ) as pivot_table
)
SELECT 
    mpd.merchant_category,
    COUNT(DISTINCT mpd.customer_id) as unique_customers,
    COALESCE(SUM(mpd.Jan_Amount), 0) as january_revenue,
    COALESCE(SUM(mpd.Feb_Amount), 0) as february_revenue,
    COALESCE(SUM(mpd.Mar_Amount), 0) as march_revenue,
    COALESCE(SUM(mpd.Apr_Amount), 0) as april_revenue,
    COALESCE(SUM(mpd.May_Amount), 0) as may_revenue,
    COALESCE(SUM(mpd.Jun_Amount), 0) as june_revenue,
    COALESCE(SUM(mpd.Jul_Amount), 0) as july_revenue,
    COALESCE(SUM(mpd.Aug_Amount), 0) as august_revenue,
    COALESCE(SUM(mpd.Sep_Amount), 0) as september_revenue,
    COALESCE(SUM(mpd.Oct_Amount), 0) as october_revenue,
    COALESCE(SUM(mpd.Nov_Amount), 0) as november_revenue,
    COALESCE(SUM(mpd.Dec_Amount), 0) as december_revenue,
    ROUND(
        (COALESCE(SUM(mpd.Dec_Amount), 0) - COALESCE(SUM(mpd.Jan_Amount), 0)) 
        / NULLIF(COALESCE(SUM(mpd.Jan_Amount), 0), 0) * 100, 
        2
    ) as year_over_year_growth_pct
FROM monthly_pivot_data mpd
WHERE EXISTS (
    SELECT 1 
    FROM transaction_base tb 
    WHERE tb.customer_id = mpd.customer_id 
        AND tb.merchant_category = mpd.merchant_category
        AND tb.transaction_period IN ('Black Friday', 'Christmas')
)
GROUP BY mpd.merchant_category
HAVING COUNT(DISTINCT mpd.customer_id) >= 50
    AND COALESCE(SUM(mpd.Jan_Amount), 0) + COALESCE(SUM(mpd.Dec_Amount), 0) > 100000
ORDER BY december_revenue DESC, unique_customers DESC;
```

## Test Query 4: Advanced Analytics with Multiple Window Functions and Complex Conditions

```sql
c
```

## Test Query 5: Stored Procedure with Error Handling and Dynamic SQL

```sql
CREATE OR REPLACE PROCEDURE generate_customer_report(
    IN p_start_date DATE,
    IN p_end_date DATE,
    IN p_customer_tier VARCHAR(50) DEFAULT NULL,
    IN p_include_inactive BOOLEAN DEFAULT FALSE,
    OUT p_total_customers INT,
    OUT p_total_revenue DECIMAL(15,2),
    OUT p_status_message VARCHAR(500)
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_sql_query TEXT;
    v_where_clause TEXT := '';
    v_customer_count INT;
    v_revenue_sum DECIMAL(15,2);
    v_error_message TEXT;
BEGIN
    -- Input validation
    IF p_start_date IS NULL OR p_end_date IS NULL THEN
        p_status_message := 'Error: Start date and end date cannot be null';
        RETURN;
    END IF;
    
    IF p_start_date > p_end_date THEN
        p_status_message := 'Error: Start date cannot be greater than end date';
        RETURN;
    END IF;
    
    -- Build dynamic WHERE clause
    v_where_clause := 'WHERE o.order_date BETWEEN $1 AND $2';
    
    IF p_customer_tier IS NOT NULL THEN
        v_where_clause := v_where_clause || ' AND c.customer_tier = $3';
    END IF;
    
    IF NOT p_include_inactive THEN
        v_where_clause := v_where_clause || ' AND c.customer_status = ''active''';
    END IF;
    
    -- Build main query
    v_sql_query := '
        WITH customer_metrics AS (
            SELECT 
                c.customer_id,
                c.customer_name,
                c.customer_email,
                c.customer_tier,
                c.registration_date,
                COUNT(DISTINCT o.order_id) as total_orders,
                SUM(o.order_amount) as total_spent,
                AVG(o.order_amount) as avg_order_value,
                MAX(o.order_date) as last_order_date,
                EXTRACT(DAYS FROM (CURRENT_DATE - MAX(o.order_date))) as days_since_last_order
            FROM customer_database.main_schema.customers c
            LEFT JOIN customer_database.main_schema.orders o ON c.customer_id = o.customer_id
            ' || v_where_clause || '
            GROUP BY c.customer_id, c.customer_name, c.customer_email, 
                     c.customer_tier, c.registration_date
            HAVING COUNT(DISTINCT o.order_id) > 0
        ),
        rfm_analysis AS (
            SELECT 
                customer_id,
                customer_name,
                total_orders,
                total_spent,
                days_since_last_order,
                NTILE(5) OVER (ORDER BY days_since_last_order ASC) as recency_score,
                NTILE(5) OVER (ORDER BY total_orders DESC) as frequency_score,
                NTILE(5) OVER (ORDER BY total_spent DESC) as monetary_score
            FROM customer_metrics
        )
        SELECT 
            COUNT(DISTINCT customer_id) as customer_count,
            SUM(total_spent) as revenue_sum
        FROM rfm_analysis';
    
    -- Execute dynamic query
    BEGIN
        IF p_customer_tier IS NOT NULL THEN
            EXECUTE v_sql_query 
            INTO v_customer_count, v_revenue_sum
            USING p_start_date, p_end_date, p_customer_tier;
        ELSE
            EXECUTE v_sql_query 
            INTO v_customer_count, v_revenue_sum
            USING p_start_date, p_end_date;
        END IF;
        
        -- Set output parameters
        p_total_customers := COALESCE(v_customer_count, 0);
        p_total_revenue := COALESCE(v_revenue_sum, 0.00);
        p_status_message := 'Success: Report generated successfully';
        
    EXCEPTION
        WHEN OTHERS THEN
            GET STACKED DIAGNOSTICS v_error_message = MESSAGE_TEXT;
            p_status_message := 'Error: ' || v_error_message;
            p_total_customers := 0;
            p_total_revenue := 0.00;
    END;
    
    -- Log the procedure execution
    INSERT INTO customer_database.audit_schema.procedure_log (
        procedure_name,
        execution_timestamp,
        input_parameters,
        output_parameters,
        status_message
    ) VALUES (
        'generate_customer_report',
        CURRENT_TIMESTAMP,
        JSON_BUILD_OBJECT(
            'start_date', p_start_date,
            'end_date', p_end_date,
            'customer_tier', p_customer_tier,
            'include_inactive', p_include_inactive
        ),
        JSON_BUILD_OBJECT(
            'total_customers', p_total_customers,
            'total_revenue', p_total_revenue
        ),
        p_status_message
    );
END;
$$;

